<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Citoyen Survivor ‚Äî V1</title>
  <style>
    :root {
      --bg0: #06070b;
      --bg1: #10131d;
      --ink: #f3f6ff;
      --muted: #9ea9bf;
      --accent: #ff4d6d;
      --accent-b: #2b4fff;
      --accent-g: #2ee6a6;
      --ballot: #ffd166;
      --scan: rgba(255, 255, 255, 0.08);
      --grain: rgba(255, 255, 255, 0.04);
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 40% -10%, #0f1224 0%, var(--bg0) 65%) fixed;
      color: var(--ink);
      font-family: "Press Start 2P", system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Arial, "Noto Sans", sans-serif;
      overflow: hidden;
    }

    #wrap {
      position: fixed;
      inset: 0;
      display: grid;
      grid-template-rows: 1fr;
    }

    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    .hud {
      position: fixed;
      left: 8px;
      top: 8px;
      display: flex;
      gap: 6px;
      align-items: center;
      pointer-events: none;
    }

    .chip {
      min-width: 52px;
      font-size: 10px;
      text-align: center;
      padding: 6px 8px;
      border-radius: 4px;
      border: 2px solid rgba(255, 255, 255, 0.15);
      background: rgba(6, 7, 11, 0.65);
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5);
    }

    .chip span { display: block; letter-spacing: 0.5px; }

    .dashHalo {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 160px;
      height: 160px;
      margin-left: -80px;
      margin-top: -80px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.12);
      pointer-events: none;
      filter: blur(0.2px);
      mix-blend-mode: screen;
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }

    .pauseBtn {
      position: fixed;
      top: 8px;
      right: 8px;
      font-size: 10px;
      background: rgba(6, 7, 11, 0.65);
      border: 2px solid rgba(255, 255, 255, 0.18);
      border-radius: 4px;
      padding: 8px 10px;
      color: var(--ink);
      cursor: pointer;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.45);
    }

    .veil {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.68));
      backdrop-filter: blur(2px);
    }

    .card {
      width: min(720px, 92vw);
      background: rgba(12, 15, 24, 0.94);
      border: 2px solid rgba(255, 255, 255, 0.18);
      border-radius: 6px;
      padding: 18px;
      box-shadow: 0 22px 60px rgba(0, 0, 0, 0.65);
    }

    .title { font-size: 18px; margin: 0 0 8px; letter-spacing: 1px; }
    .subtitle { color: var(--muted); font-size: 11px; line-height: 1.6; margin: 0 0 12px; }

    .btn {
      display: inline-block;
      background: #1b2438;
      border: 2px solid rgba(255, 255, 255, 0.25);
      color: var(--ink);
      padding: 10px 14px;
      border-radius: 6px;
      cursor: pointer;
    }

    .panel {
      margin-top: 12px;
      font-size: 11px;
      line-height: 1.6;
      background: rgba(6, 7, 11, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 6px;
      padding: 12px;
    }

    .panel pre {
      margin: 0;
      font-family: "Fira Code", "Source Code Pro", monospace;
      font-size: 11px;
      color: var(--muted);
    }

    .joystick {
      position: fixed;
      left: 16px;
      bottom: 16px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.15);
      background: rgba(12, 15, 24, 0.5);
      touch-action: none;
    }

    .stick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.14);
      border: 2px solid rgba(255, 255, 255, 0.25);
    }

    .actions {
      position: fixed;
      right: 12px;
      bottom: 16px;
      display: flex;
      gap: 12px;
    }

    .round {
      width: 66px;
      height: 66px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.25);
      background: rgba(12, 15, 24, 0.5);
      display: grid;
      place-items: center;
      font-size: 20px;
      color: var(--ink);
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.45);
    }

    .overlay-hidden { display: none; }

    .crt { position: fixed; inset: 0; pointer-events: none; mix-blend-mode: screen; }
    .grain { position: fixed; inset: 0; pointer-events: none; mix-blend-mode: soft-light; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="screen"></canvas>
    <canvas id="crt" class="crt"></canvas>
    <canvas id="grain" class="grain"></canvas>

    <div class="dashHalo" id="dashHalo"></div>

    <div class="hud">
      <div class="chip" id="hudTime"><span>‚è≥</span><span id="time">00:00</span></div>
      <div class="chip" id="hudLevel"><span>‚¨ÜÔ∏è</span><span id="level">1</span></div>
      <div class="chip" id="hudBallot"><span>üó≥Ô∏è</span><span id="ballots">0</span></div>
      <div class="chip" id="hudDash"><span>‚ö°</span><span id="dash">0</span></div>
      <div class="chip" id="hudBomb"><span>üì£</span><span id="bomb">1</span></div>
    </div>
    <button class="pauseBtn" id="pause" title="Pause">‚è∏Ô∏è</button>

    <div class="veil" id="start">
      <div class="card">
        <div class="title">CITOYEN SURVIVOR ¬∑ V1</div>
        <p class="subtitle">
          Mode survie infini : intensit√© croissante, crises, upgrades visuelles.<br />
          Mobile : joystick + ‚ö° dash, üì£ appel citoyen.
        </p>
        <button class="btn" id="play">‚ñ∂Ô∏è LANCER</button>
        <div class="panel">
          <pre>
Contr√¥les : WASD / ZQSD / fl√®ches, souris pour viser.
Dash ‚ö° (Space / Shift) ‚Äî Appel üì£ (E).
Pause = P ou bouton. Bestiaire dans la pause.
          </pre>
        </div>
      </div>
    </div>

    <div class="veil overlay-hidden" id="overlay">
      <div class="card" id="overlayCard"></div>
    </div>

    <div class="joystick" id="joy"><div class="stick" id="stick"></div></div>
    <div class="actions">
      <div class="round" id="dashBtn" title="Dash">‚ö°</div>
      <div class="round" id="bombBtn" title="Appel citoyen">üì£</div>
    </div>
  </div>

  <script>
    (function () {
      const VIRT_W = 208;
      const VIRT_H = 117;
      const SCALE_BASE = 3;

      const screen = document.getElementById('screen');
      const ctx = screen.getContext('2d');
      ctx.imageSmoothingEnabled = false;

      const crt = document.getElementById('crt');
      const crtCtx = crt.getContext('2d');
      crtCtx.imageSmoothingEnabled = false;
      const grain = document.getElementById('grain');
      const grainCtx = grain.getContext('2d');
      grainCtx.imageSmoothingEnabled = false;

      const off = document.createElement('canvas');
      off.width = VIRT_W;
      off.height = VIRT_H;
      const g = off.getContext('2d');
      g.imageSmoothingEnabled = false;

      let W = 0, H = 0, S = SCALE_BASE;
      function fit() {
        W = innerWidth;
        H = innerHeight;
        S = Math.max(1, Math.floor(Math.min(W / VIRT_W, H / VIRT_H)));
        const viewW = VIRT_W * S;
        const viewH = VIRT_H * S;
        screen.width = viewW;
        screen.height = viewH;
        screen.style.width = viewW + 'px';
        screen.style.height = viewH + 'px';
        crt.width = viewW;
        crt.height = viewH;
        crt.style.width = viewW + 'px';
        crt.style.height = viewH + 'px';
        grain.width = viewW;
        grain.height = viewH;
        grain.style.width = viewW + 'px';
        grain.style.height = viewH + 'px';
        const left = Math.floor((W - viewW) / 2);
        const top = Math.floor((H - viewH) / 2);
        screen.style.position = crt.style.position = grain.style.position = 'fixed';
        screen.style.left = crt.style.left = grain.style.left = left + 'px';
        screen.style.top = crt.style.top = grain.style.top = top + 'px';
      }
      addEventListener('resize', fit);
      fit();

      const PAL = {
        K: '#040507',
        W: '#f8faff',
        B: '#2f4fe0',
        R: '#ff4d6d',
        Y: '#ffd166',
        C: '#67d1ff',
        G: '#2ee6a6',
        O: '#f9723b',
        P: '#b164ff',
        S: '#596179',
        N: '#10131d',
      };

      function makeSprite(map, colors, w = 16, h = 16) {
        const canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        const x = canvas.getContext('2d');
        const img = x.createImageData(w, h);
        for (let y = 0; y < h; y++) {
          const row = map[y];
          for (let c = 0; c < w; c++) {
            const code = row[c];
            const color = colors[code] || 'transparent';
            const idx = (y * w + c) * 4;
            if (color === 'transparent' || color === '.') {
              img.data[idx + 3] = 0;
            } else {
              const hex = PAL[color] || color;
              const r = parseInt(hex.substr(1, 2), 16);
              const g = parseInt(hex.substr(3, 2), 16);
              const b = parseInt(hex.substr(5, 2), 16);
              img.data[idx] = r;
              img.data[idx + 1] = g;
              img.data[idx + 2] = b;
              img.data[idx + 3] = 255;
            }
          }
        }
        x.putImageData(img, 0, 0);
        return canvas;
      }

      const SPRITES = {};
      SPRITES.player = [
        makeSprite([
          '................',
          '.....BBBB........',
          '....BWWWWB.......',
          '...BWWSWWWB......',
          '...BWWWWWB......',
          '..BWWWWWWWB.....',
          '..BWWSWWWWB.....',
          '..BWWWWWBBB.....',
          '..BWWWWB........',
          '..BWWWWB........',
          '...BWWB.........',
          '...BWWB.........',
          '....BB..........',
          '...BBBB.........',
          '..BB..BB........',
          '................',
        ], { B: 'B', W: 'W', S: 'S' }),
        makeSprite([
          '................',
          '.....BBBB........',
          '....BWWWWB.......',
          '...BWWSWWWB......',
          '...BWWWWWB......',
          '..BWWWWWWWB.....',
          '..BWWWSWWWB.....',
          '..BWWWWBBBB.....',
          '..BWWWWB........',
          '..BWWWWB........',
          '...BWWB.........',
          '...BWWB.........',
          '....BB..........',
          '....BBBB........',
          '...BB..BB.......',
          '................',
        ], { B: 'B', W: 'W', S: 'S' })
      ];

      SPRITES.halo = makeSprite([
        '................',
        '................',
        '.....CCCCCC.....',
        '...CC......CC...',
        '..C..........C..',
        '.C............C.',
        '.C............C.',
        'C..............C',
        'C..............C',
        '.C............C.',
        '.C............C.',
        '..C..........C..',
        '...CC......CC...',
        '.....CCCCCC.....',
        '................',
        '................',
      ], { C: 'C' });

      const ENEMY_SPR = {
        decree: makeSprite([
          '................',
          '........BBBB....',
          '.......BWWWWB...',
          '......BWWWWWWB..',
          '......BWWWWWWB..',
          '.......BWWWWB...',
          '........BBBB....',
          '.....BBBBBBBB...',
          '....BWWWWWWWWB..',
          '....BWWWWWWWWB..',
          '.....BBBBBBBB...',
          '........BBBB....',
          '................',
          '................',
          '................',
          '................',
        ], { B: 'B', W: 'W' }),
        expert: makeSprite([
          '................',
          '......SSSS......',
          '.....SWWWS......',
          '....SWWWWWS.....',
          '...SWWWWWWWS....',
          '..SWWWWWWWWWS...',
          '..SWWWWWWWWWS...',
          '...SWWWWWWWS....',
          '....SWWWWWS.....',
          '......SWWWS.....',
          '......SSSS......',
          '......S..S......',
          '.....S....S.....',
          '................',
          '................',
          '................',
        ], { S: 'S', W: 'W' }),
        burst: makeSprite([
          '................',
          '......RRRR......',
          '.....RWWWWR.....',
          '....RWRRRWR....',
          '....RWRRRWR....',
          '....RWRRRWR....',
          '.....RWRWR.....',
          '......RRRR......',
          '......R..R......',
          '.....R....R.....',
          '....R......R....',
          '................',
          '................',
          '................',
          '................',
          '................',
        ], { R: 'R', W: 'W' }),
        dossier: makeSprite([
          '................',
          '....NNNNNNNN....',
          '...NWNNNNNNWN...',
          '..NWWNNNNNNWWN..',
          '..NWWNNNNNNWWN..',
          '..NWWWWWWWWWWN..',
          '..NWWWWWWWWWWN..',
          '..NWWNNNNNNWWN..',
          '..NWWNNNNNNWWN..',
          '..NWWNNNNNNWWN..',
          '...NWNNNNNNWN...',
          '....NNNNNNNN....',
          '................',
          '................',
          '................',
          '................',
        ], { N: 'N', W: 'W' }),
        reco: makeSprite([
          '................',
          '.....CCCCCC.....',
          '....CBBBBBBC....',
          '...CBWWWWWWBC...',
          '...CBWWWWWWBC...',
          '....CBBBBBBC....',
          '.....CCCCCC.....',
          '....CBBBBBBC....',
          '...CBWWWWWWBC...',
          '...CBWWWWWWBC...',
          '....CBBBBBBC....',
          '.....CCCCCC.....',
          '................',
          '................',
          '................',
          '................',
        ], { C: 'C', B: 'B', W: 'W' }),
        systemic: makeSprite([
          '................',
          '....BBBBRRRR....',
          '...BBWWRRWWBB...',
          '..BWWSWWWWSSWB..',
          '..BWSSWWWWSSWB..',
          '..BWWSSWWSSWWB..',
          '..BWWWSSSSWWWB..',
          '..BWWWWSSWWWBB..',
          '..BWWWWWSSWWWB..',
          '..BWSSWWWWSSWB..',
          '..BWWSWWWWSSWB..',
          '...BBWWRRWWBB...',
          '....BBBBRRRR....',
          '................',
          '................',
          '................',
        ], { B: 'B', R: 'R', W: 'W', S: 'S' }),
      };

      const FX_SPARK = makeSprite([
        '................',
        '................',
        '.......YY.......',
        '......YYYY......',
        '.......YY.......',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
        '................',
      ], { Y: 'Y' }, 16, 16);

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const sounds = {
        shoot: 'data:audio/wav;base64,UklGRjwAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQwAAAAgICAnJyYmJiAgICcnJyYmJiYmJiYmJiYm',
        hit: 'data:audio/wav;base64,UklGRi4AAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQgAAAAwMDAzMzMyMjIyMzMyMjIyMjIyMjIyMjIy',
        dash: 'data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQUAAAAoKCgoKCwsLCwsLCwsLCwsLCws',
        xp: 'data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQUAAAAcHBwcHCAgICAgICAgICAgICAgICAg',
        bomb: 'data:audio/wav;base64,UklGRj4AAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQwAAAA/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pw==',
        alert: 'data:audio/wav;base64,UklGRjgAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ0AAAAQEBAQEBAQEBAQEBAQEBAQEBAQEB',
      };

      function playSound(key, gain = 0.35, rate = 1) {
        const src = sounds[key];
        if (!src) return;
        fetch(src)
          .then(res => res.arrayBuffer())
          .then(buf => audioCtx.decodeAudioData(buf))
          .then(audioBuffer => {
            const node = audioCtx.createBufferSource();
            node.buffer = audioBuffer;
            node.playbackRate.value = rate;
            const g = audioCtx.createGain();
            g.gain.value = gain;
            node.connect(g).connect(audioCtx.destination);
            node.start(0);
          })
          .catch(() => {});
      }

      const state = {
        running: false,
        paused: false,
        over: false,
        time: 0,
        level: 1,
        xp: 0,
        xpTarget: 30,
        ballots: 0,
        bombs: 1,
        dash: { ready: true, timer: 0, cooldown: 6, duration: 0.18 },
        haloPulse: 0,
        camera: { x: 0, y: 0, shake: 0 },
        stats: {
          kills: { decree: 0, expert: 0, burst: 0, dossier: 0, reco: 0, systemic: 0 },
        },
        player: {
          x: VIRT_W / 2,
          y: VIRT_H / 2,
          vx: 0,
          vy: 0,
          angle: 0,
          speed: 48,
          baseSpeed: 48,
          hp: 120,
          max: 120,
          ifr: 0,
          dash: 0,
          sign: 1,
        },
        weapon: {
          cooldown: 0,
          rate: 0.55,
          projectiles: 1,
          spread: 0.18,
          damage: 8,
          speed: 110,
        },
        upgrades: [],
        projectiles: [],
        enemies: [],
        effects: [],
        orbs: [],
        ballotsItems: [],
        spawn: {
          timer: 0,
          density: 0,
        },
        bestiary: {},
        lastSystemic: 0,
      };

      const PROGRESSION = {
        xp: [30, 50, 80, 120, 180, 260, 360, 480, 620, 780, 960, 1160, 1380, 1620, 1880, 2160, 2460, 2780, 3120, 3480],
        upgrades: [
          { id: 'firerate', icon: 'üîÅ', text: 'Cadence accrue', effect: () => { state.weapon.rate = Math.max(0.32, state.weapon.rate - 0.06); } },
          { id: 'spread', icon: 'üéØ', text: 'Dispersion ma√Ætris√©e', effect: () => { state.weapon.spread = Math.max(0.06, state.weapon.spread - 0.02); } },
          { id: 'burst', icon: 'üí•', text: 'Dommages major√©s', effect: () => { state.weapon.damage += 2; } },
          { id: 'orb', icon: 'üß≤', text: 'Collecte magn√©tique', effect: () => { playerMagnet += 10; } },
          { id: 'speed', icon: 'üëü', text: 'Mouvement fluide', effect: () => { state.player.baseSpeed += 4; } },
          { id: 'bomb', icon: 'üì£', text: 'Appel renforc√©', effect: () => { state.bombs += 1; } },
          { id: 'dash', icon: '‚ö°', text: 'Dash condens√©', effect: () => { state.dash.cooldown = Math.max(3.2, state.dash.cooldown - 0.6); } },
        ],
        enemyHp: {
          decree: t => 12 + t * 2.5,
          expert: t => 40 + t * 3.2,
          burst: t => 24 + t * 2.8,
          dossier: t => 110 + t * 5,
          reco: t => 45 + t * 3.5,
          systemic: t => 550 + t * 15,
        },
        enemySpeed: {
          decree: t => 32 + t * 0.9,
          expert: t => 26 + t * 0.7,
          burst: t => 36 + t * 0.8,
          dossier: t => 18 + t * 0.5,
          reco: t => 20 + Math.sin(t * 0.3) * 6 + t * 0.3,
          systemic: t => 28 + t * 0.45,
        },
      };

      let playerMagnet = 24;

      function getXpTarget(level) {
        return PROGRESSION.xp[Math.min(PROGRESSION.xp.length - 1, level - 1)] || (3500 + (level - PROGRESSION.xp.length) * 400);
      }

      function addEffect(x, y, life, color, size = 2) {
        state.effects.push({ x, y, life, maxLife: life, color, size });
      }

      function spawnOrb(x, y, value) {
        state.orbs.push({ x, y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, value, life: 12 });
      }

      function spawnBallot(x, y) {
        state.ballotsItems.push({ x, y, vx: (Math.random() - 0.5) * 18, vy: (Math.random() - 0.5) * 18, life: 16 });
      }

      function spawnProjectile() {
        const { player, weapon } = state;
        const base = player.angle;
        const count = weapon.projectiles;
        for (let i = 0; i < count; i++) {
          const ang = base + (Math.random() - 0.5) * weapon.spread;
          const speed = weapon.speed;
          const vx = Math.cos(ang) * speed;
          const vy = Math.sin(ang) * speed;
          state.projectiles.push({
            x: player.x + Math.cos(ang) * 6,
            y: player.y + Math.sin(ang) * 6,
            vx,
            vy,
            damage: weapon.damage,
            life: 1.2,
          });
        }
        playSound('shoot', 0.14, 1.1 + Math.random() * 0.1);
      }

      function spawnEnemy(type, x, y) {
        const diff = Math.min(12, Math.floor(state.time / 60));
        const hpFn = PROGRESSION.enemyHp[type];
        const spFn = PROGRESSION.enemySpeed[type];
        const hp = hpFn ? hpFn(diff) : 20;
        const speed = spFn ? spFn(diff) : 20;
        const enemy = {
          type,
          x,
          y,
          hp,
          max: hp,
          speed,
          dir: Math.random() * Math.PI * 2,
          timer: 0,
          anim: 0,
          frame: 0,
          wobble: Math.random() * Math.PI * 2,
        };
        if (type === 'systemic') {
          enemy.hp *= 1 + diff * 0.25;
          enemy.max = enemy.hp;
          enemy.radius = 16;
        } else if (type === 'dossier') {
          enemy.radius = 12;
        } else {
          enemy.radius = 8;
        }
        state.enemies.push(enemy);
        if (!state.bestiary[type]) state.bestiary[type] = { hp: enemy.max, speed: speed, kills: 0 };
        state.bestiary[type].hp = Math.max(state.bestiary[type].hp, enemy.max);
        state.bestiary[type].speed = Math.max(state.bestiary[type].speed, speed);
      }

      function spawnRing(x, y) {
        for (let i = 0; i < 16; i++) {
          const ang = (i / 16) * Math.PI * 2;
          state.effects.push({ x, y, vx: Math.cos(ang) * 40, vy: Math.sin(ang) * 40, life: 0.45, maxLife: 0.45, color: PAL.R, size: 1 });
        }
      }

      function systemicAlert() {
        addEffect(state.player.x, state.player.y, 0.8, PAL.P, 5);
        state.camera.shake = 6;
        playSound('alert', 0.3, 0.7);
      }

      function spawnSystemic() {
        const margin = 10;
        const x = Math.random() < 0.5 ? (Math.random() * VIRT_W) : (Math.random() < 0.5 ? -margin : VIRT_W + margin);
        const y = Math.random() < 0.5 ? (Math.random() * VIRT_H) : (Math.random() < 0.5 ? -margin : VIRT_H + margin);
        spawnEnemy('systemic', x, y);
        systemicAlert();
      }

      function enemyBehavior(enemy, dt) {
        const player = state.player;
        enemy.timer += dt;
        enemy.wobble += dt * 4;
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy) || 1;
        const dirToPlayer = Math.atan2(dy, dx);
        const accelerate = (speedMult = 1, offset = 0) => {
          enemy.x += Math.cos(dirToPlayer + offset) * enemy.speed * speedMult * dt;
          enemy.y += Math.sin(dirToPlayer + offset) * enemy.speed * speedMult * dt;
        };
        switch (enemy.type) {
          case 'decree': {
            const oscillation = Math.sin(enemy.timer * 6 + enemy.wobble) * 0.35;
            enemy.x += Math.cos(dirToPlayer + oscillation) * enemy.speed * dt;
            enemy.y += Math.sin(dirToPlayer + oscillation) * enemy.speed * dt;
            break;
          }
          case 'expert': {
            const talk = Math.sin(enemy.timer * 8) * 0.6;
            enemy.dir = dirToPlayer + talk * 0.4;
            enemy.x += Math.cos(enemy.dir) * enemy.speed * dt;
            enemy.y += Math.sin(enemy.dir) * enemy.speed * dt;
            break;
          }
          case 'burst': {
            enemy.dir = dirToPlayer;
            accelerate(1.05);
            if (dist < 14) {
              enemy.hp = 0;
              spawnRing(enemy.x, enemy.y);
              damagePlayer(24, enemy.x, enemy.y);
            }
            break;
          }
          case 'dossier': {
            const slowWave = Math.sin(enemy.timer * 1.5) * 0.3;
            enemy.x += Math.cos(dirToPlayer + slowWave) * enemy.speed * 0.8 * dt;
            enemy.y += Math.sin(dirToPlayer + slowWave) * enemy.speed * 0.8 * dt;
            break;
          }
          case 'reco': {
            const floatAng = dirToPlayer + Math.sin(enemy.timer * 2.5) * 0.7;
            const drift = Math.cos(enemy.timer * 3.4) * 0.5;
            enemy.x += Math.cos(floatAng) * enemy.speed * 0.9 * dt;
            enemy.y += Math.sin(floatAng) * enemy.speed * 0.9 * dt;
            enemy.x += Math.cos(enemy.wobble) * drift;
            enemy.y += Math.sin(enemy.wobble) * drift;
            break;
          }
          case 'systemic': {
            const swirl = Math.sin(enemy.timer * 0.8) * 0.6;
            enemy.x += Math.cos(dirToPlayer + swirl) * enemy.speed * dt;
            enemy.y += Math.sin(dirToPlayer + swirl) * enemy.speed * dt;
            if (enemy.timer > 1.6) {
              enemy.timer = 0.2;
              shootSpiral(enemy);
            }
            break;
          }
        }
      }

      function shootSpiral(enemy) {
        for (let i = 0; i < 12; i++) {
          const ang = (i / 12) * Math.PI * 2 + Math.random() * 0.1;
          state.projectiles.push({
            x: enemy.x,
            y: enemy.y,
            vx: Math.cos(ang) * 40,
            vy: Math.sin(ang) * 40,
            damage: 0,
            enemyShot: true,
            life: 3,
          });
        }
        playSound('alert', 0.25, 1.4);
      }

      function damagePlayer(amount, x, y) {
        const player = state.player;
        if (player.ifr > 0 || state.over) return;
        player.hp -= amount;
        if (player.hp <= 0) {
          player.hp = 0;
          gameOver();
        }
        player.ifr = 1;
        state.camera.shake = Math.min(8, state.camera.shake + amount * 0.08);
        addEffect(x, y, 0.4, PAL.R, 3);
        playSound('hit', 0.25, 0.9 + Math.random() * 0.1);
      }

      function killEnemy(enemy) {
        const idx = state.enemies.indexOf(enemy);
        if (idx !== -1) state.enemies.splice(idx, 1);
        const xpValue = 8 + Math.random() * 4;
        spawnOrb(enemy.x, enemy.y, xpValue);
        if (Math.random() < 0.12) spawnBallot(enemy.x, enemy.y);
        addEffect(enemy.x, enemy.y, 0.5, PAL.W, 2);
        playSound('hit', 0.18, 1.4);
        state.stats.kills[enemy.type] = (state.stats.kills[enemy.type] || 0) + 1;
        if (!state.bestiary[enemy.type]) state.bestiary[enemy.type] = { hp: enemy.max, speed: enemy.speed, kills: 1 };
        else state.bestiary[enemy.type].kills += 1;
        if (enemy.type === 'burst') {
          spawnRing(enemy.x, enemy.y);
        }
        if (enemy.type === 'systemic') {
          state.ballots += 3;
          state.bombs += 1;
          playSound('bomb', 0.3, 0.8);
        }
      }

      function collectOrb(orb, dt) {
        const dx = state.player.x - orb.x;
        const dy = state.player.y - orb.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 2) {
          state.xp += orb.value;
          playSound('xp', 0.22, 1.2 + Math.random() * 0.2);
          levelCheck();
          return true;
        }
        const pull = Math.max(0, playerMagnet - dist);
        orb.vx += (dx / (dist || 1)) * pull * dt * 2;
        orb.vy += (dy / (dist || 1)) * pull * dt * 2;
        orb.x += orb.vx * dt;
        orb.y += orb.vy * dt;
        orb.life -= dt;
        return orb.life <= 0;
      }

      function collectBallot(item, dt) {
        const dx = state.player.x - item.x;
        const dy = state.player.y - item.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 2.5) {
          state.ballots += 1;
          playSound('xp', 0.22, 0.6 + Math.random() * 0.2);
          return true;
        }
        item.vx *= 0.95;
        item.vy *= 0.95;
        item.x += item.vx * dt;
        item.y += item.vy * dt;
        item.life -= dt;
        return item.life <= 0;
      }

      function levelCheck() {
        if (state.xp >= state.xpTarget) {
          state.xp -= state.xpTarget;
          state.level += 1;
          state.xpTarget = getXpTarget(state.level);
          pauseGame(true);
          showUpgradePanel();
        }
      }

      function showUpgradePanel() {
        const overlay = document.getElementById('overlay');
        const card = document.getElementById('overlayCard');
        overlay.classList.remove('overlay-hidden');
        overlay.dataset.mode = 'upgrade';
        const choices = [...PROGRESSION.upgrades];
        choices.sort(() => Math.random() - 0.5);
        const pick = choices.slice(0, 3);
        card.innerHTML = '<div class="title">UPGRADE</div><p class="subtitle">Choisis un symbole</p>';
        pick.forEach(upg => {
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.textContent = `${upg.icon} ${upg.text}`;
          btn.onclick = () => {
            upg.effect();
            overlay.classList.add('overlay-hidden');
            resumeGame();
          };
          card.appendChild(btn);
          card.appendChild(document.createElement('br'));
        });
      }

      function updateHUD() {
        document.getElementById('time').textContent = formatTime(state.time);
        document.getElementById('level').textContent = state.level;
        document.getElementById('ballots').textContent = state.ballots;
        document.getElementById('bomb').textContent = state.bombs;
        const dash = document.getElementById('dash');
        dash.textContent = state.dash.ready ? '0' : state.dash.timer.toFixed(1);
      }

      function formatTime(time) {
        const t = Math.floor(time);
        const m = Math.floor(t / 60);
        const s = t % 60;
        return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      }

      function togglePause() {
        if (state.over) return;
        if (state.paused) {
          resumeGame();
        } else {
          pauseGame(false);
          showPausePanel();
        }
      }

      function pauseGame(levelUp) {
        state.paused = true;
        state.running = false;
        if (!levelUp) playSound('alert', 0.2, 0.6);
      }

      function resumeGame() {
        const overlay = document.getElementById('overlay');
        overlay.classList.add('overlay-hidden');
        state.paused = false;
        state.running = true;
        last = performance.now();
        loop();
      }

      function showPausePanel() {
        const overlay = document.getElementById('overlay');
        const card = document.getElementById('overlayCard');
        overlay.classList.remove('overlay-hidden');
        overlay.dataset.mode = 'pause';
        const lines = buildBestiary();
        card.innerHTML = `<div class="title">BESTIAIRE</div><div class="panel"><pre>${lines}</pre></div>`;
        const resume = document.createElement('button');
        resume.className = 'btn';
        resume.textContent = '‚ñ∂Ô∏è Continuer';
        resume.onclick = () => {
          overlay.classList.add('overlay-hidden');
          resumeGame();
        };
        card.appendChild(resume);
      }

      function buildBestiary() {
        const header = 'TYPE               PV    VIT.   ABATTUS\n';
        const pad = (str, len) => (str + ' '.repeat(len)).slice(0, len);
        const map = {
          decree: 'D√©cret volant',
          expert: 'Expert TV',
          burst: 'Crise ponctuelle',
          dossier: 'Dossier secret',
          reco: 'Reco. europ√©enne',
          systemic: 'Crise syst√©mique',
        };
        let body = '';
        for (const key of Object.keys(map)) {
          const info = state.bestiary[key] || { hp: 0, speed: 0, kills: 0 };
          body += `${pad(map[key], 18)}${pad(Math.round(info.hp), 6)}${pad(Math.round(info.speed), 7)}${pad(info.kills, 8)}\n`;
        }
        body += '\nTOTAL üó≥Ô∏è : ' + state.ballots + '    TEMPS : ' + formatTime(state.time) + '    NIVEAU : ' + state.level;
        return header + body;
      }

      function showGameOver() {
        const overlay = document.getElementById('overlay');
        const card = document.getElementById('overlayCard');
        overlay.classList.remove('overlay-hidden');
        overlay.dataset.mode = 'over';
        const bestiary = buildBestiary();
        card.innerHTML = `<div class="title">CR√âDITS</div><div class="panel"><pre>${bestiary}</pre></div>`;
        const retry = document.createElement('button');
        retry.className = 'btn';
        retry.textContent = '‚Üª REJOUER';
        retry.onclick = () => location.reload();
        card.appendChild(retry);
      }

      function gameOver() {
        state.over = true;
        state.running = false;
        playSound('bomb', 0.3, 0.6);
        showGameOver();
      }

      const dashHalo = document.getElementById('dashHalo');
      const joy = document.getElementById('joy');
      const stick = document.getElementById('stick');
      const dashBtn = document.getElementById('dashBtn');
      const bombBtn = document.getElementById('bombBtn');
      let joyActive = false;
      let joyVec = { x: 0, y: 0 };

      function joyUpdate(e) {
        const rect = joy.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const dx = x - rect.width / 2;
        const dy = y - rect.height / 2;
        const dist = Math.hypot(dx, dy);
        const max = rect.width * 0.35;
        const clamped = Math.min(dist, max);
        const nx = dx / (dist || 1);
        const ny = dy / (dist || 1);
        stick.style.transform = `translate(calc(-50% + ${nx * clamped}px), calc(-50% + ${ny * clamped}px))`;
        joyVec.x = Math.max(-1, Math.min(1, dx / max));
        joyVec.y = Math.max(-1, Math.min(1, dy / max));
      }

      joy.addEventListener('touchstart', e => { joyActive = true; joyUpdate(e); }, { passive: false });
      joy.addEventListener('touchmove', e => { if (joyActive) joyUpdate(e); }, { passive: false });
      joy.addEventListener('touchend', () => { joyActive = false; stick.style.transform = 'translate(-50%, -50%)'; joyVec.x = joyVec.y = 0; });

      const keys = {};
      addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === ' ') e.preventDefault();
        if (e.key === 'p') { togglePause(); }
        if (e.key === 'Escape') { togglePause(); }
        if (e.key === 'e') { triggerBomb(); }
      });
      addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

      let mousePos = { x: VIRT_W / 2, y: VIRT_H / 2 };
      addEventListener('mousemove', e => {
        const rect = screen.getBoundingClientRect();
        mousePos.x = (e.clientX - rect.left) / S;
        mousePos.y = (e.clientY - rect.top) / S;
      });

      addEventListener('mousedown', e => { if (!state.running && !state.over) startGame(); });

      dashBtn.addEventListener('touchstart', e => { e.preventDefault(); triggerDash(); }, { passive: false });
      dashBtn.addEventListener('click', triggerDash);
      bombBtn.addEventListener('touchstart', e => { e.preventDefault(); triggerBomb(); }, { passive: false });
      bombBtn.addEventListener('click', triggerBomb);

      function triggerDash() {
        if (!state.dash.ready || state.player.dash > 0) return;
        state.player.dash = state.dash.duration;
        state.dash.ready = false;
        state.dash.timer = state.dash.cooldown;
        state.player.ifr = 0.3;
        dashHalo.style.opacity = 0.85;
        state.camera.shake = 4;
        playSound('dash', 0.25, 1.2);
      }

      function triggerBomb() {
        if (state.bombs <= 0 && state.ballots < 3) return;
        if (state.bombs > 0) state.bombs -= 1; else state.ballots -= 3;
        playSound('bomb', 0.36, 0.8);
        state.camera.shake = 12;
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          if (enemy.type === 'systemic') {
            enemy.hp -= 150;
            if (enemy.hp <= 0) killEnemy(enemy);
          } else {
            killEnemy(enemy);
          }
        }
      }

      function startGame() {
        document.getElementById('start').classList.add('overlay-hidden');
        state.running = true;
        state.time = 0;
        state.xpTarget = getXpTarget(state.level);
        last = performance.now();
        loop();
      }

      document.getElementById('play').addEventListener('click', () => {
        audioCtx.resume();
        startGame();
      });
      document.getElementById('play').addEventListener('touchend', () => {
        audioCtx.resume();
        startGame();
      }, { passive: false });

      document.getElementById('pause').addEventListener('click', togglePause);

      let last = 0;
      function loop(timestamp) {
        if (!state.running) return;
        const now = timestamp || performance.now();
        let dt = (now - last) / 1000;
        if (dt > 0.08) dt = 0.08;
        last = now;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }

      function update(dt) {
        state.time += dt;
        updateHUD();
        const player = state.player;

        state.spawn.timer -= dt;
        const difficulty = 1 + state.time / 50;
        if (state.spawn.timer <= 0) {
          state.spawn.timer = Math.max(0.2, 1.4 / difficulty);
          const type = pickEnemyType();
          const edge = spawnPoint();
          spawnEnemy(type, edge.x, edge.y);
        }

        if (state.time - state.lastSystemic > 120) {
          state.lastSystemic = state.time;
          spawnSystemic();
        }

        if (state.weapon.cooldown > 0) state.weapon.cooldown -= dt; else {
          spawnProjectile();
          state.weapon.cooldown = state.weapon.rate;
        }

        let inputX = 0, inputY = 0;
        if (keys['arrowleft'] || keys['a'] || keys['q']) inputX -= 1;
        if (keys['arrowright'] || keys['d']) inputX += 1;
        if (keys['arrowup'] || keys['w'] || keys['z']) inputY -= 1;
        if (keys['arrowdown'] || keys['s']) inputY += 1;
        if (joyActive) { inputX += joyVec.x; inputY += joyVec.y; }
        const len = Math.hypot(inputX, inputY);
        const dashMultiplier = player.dash > 0 ? 2.4 : 1;
        const speed = (player.baseSpeed + state.level * 0.6) * dashMultiplier;
        if (len > 0.1) {
          player.vx = (inputX / len) * speed;
          player.vy = (inputY / len) * speed;
        } else {
          player.vx *= 0.85;
          player.vy *= 0.85;
        }
        player.x += player.vx * dt;
        player.y += player.vy * dt;
        player.x = Math.max(6, Math.min(VIRT_W - 6, player.x));
        player.y = Math.max(6, Math.min(VIRT_H - 6, player.y));
        player.angle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x);

        if (keys[' '] || keys['shift']) triggerDash();

        if (player.dash > 0) player.dash -= dt; else player.dash = 0;
        if (!state.dash.ready) {
          state.dash.timer = Math.max(0, state.dash.timer - dt);
          if (state.dash.timer <= 0) {
            state.dash.ready = true;
          }
        }
        if (player.dash > 0) {
          dashHalo.style.opacity = 0.85;
        } else {
          dashHalo.style.opacity = state.dash.ready ? 0.35 : 0.05;
        }

        if (player.ifr > 0) player.ifr -= dt;
        if (player.hp < player.max) player.hp += dt * 1.5;

        for (let i = state.orbs.length - 1; i >= 0; i--) {
          if (collectOrb(state.orbs[i], dt)) state.orbs.splice(i, 1);
        }
        for (let i = state.ballotsItems.length - 1; i >= 0; i--) {
          if (collectBallot(state.ballotsItems[i], dt)) state.ballotsItems.splice(i, 1);
        }

        for (let i = state.projectiles.length - 1; i >= 0; i--) {
          const p = state.projectiles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life -= dt;
          if (p.life <= 0 || p.x < -10 || p.y < -10 || p.x > VIRT_W + 10 || p.y > VIRT_H + 10) {
            state.projectiles.splice(i, 1);
            continue;
          }
          if (p.enemyShot) {
            if (Math.hypot(p.x - player.x, p.y - player.y) < 6) {
              damagePlayer(14, p.x, p.y);
              state.projectiles.splice(i, 1);
            }
          } else {
            for (let j = state.enemies.length - 1; j >= 0; j--) {
              const enemy = state.enemies[j];
              if (Math.hypot(p.x - enemy.x, p.y - enemy.y) < enemy.radius) {
                enemy.hp -= p.damage;
                addEffect(p.x, p.y, 0.2, PAL.Y, 1);
                state.projectiles.splice(i, 1);
                if (enemy.hp <= 0) {
                  killEnemy(enemy);
                }
                break;
              }
            }
          }
        }

        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          enemyBehavior(enemy, dt);
          if (Math.hypot(enemy.x - player.x, enemy.y - player.y) < enemy.radius + 4) {
            damagePlayer(12, enemy.x, enemy.y);
            enemy.hp -= 10;
            if (enemy.hp <= 0) killEnemy(enemy);
          }
          if (enemy.x < -30 || enemy.y < -30 || enemy.x > VIRT_W + 30 || enemy.y > VIRT_H + 30) {
            enemy.x = Math.max(-24, Math.min(VIRT_W + 24, enemy.x));
            enemy.y = Math.max(-24, Math.min(VIRT_H + 24, enemy.y));
          }
        }

        for (let i = state.effects.length - 1; i >= 0; i--) {
          const fx = state.effects[i];
          if (fx.vx !== undefined) {
            fx.x += fx.vx * dt;
            fx.y += fx.vy * dt;
          }
          fx.life -= dt;
          if (fx.life <= 0) state.effects.splice(i, 1);
        }

        if (state.camera.shake > 0) state.camera.shake -= dt * 10; else state.camera.shake = 0;

        state.haloPulse += dt * 4;
      }

      function pickEnemyType() {
        const t = state.time;
        const weights = [];
        weights.push({ type: 'decree', w: 50 });
        if (t > 15) weights.push({ type: 'expert', w: 14 + t * 0.1 });
        if (t > 30) weights.push({ type: 'burst', w: 10 + t * 0.08 });
        if (t > 50) weights.push({ type: 'dossier', w: 8 + t * 0.06 });
        if (t > 70) weights.push({ type: 'reco', w: 12 + t * 0.05 });
        let sum = weights.reduce((acc, cur) => acc + cur.w, 0);
        let r = Math.random() * sum;
        for (const w of weights) {
          if ((r -= w.w) <= 0) return w.type;
        }
        return 'decree';
      }

      function spawnPoint() {
        const margin = 6;
        const side = Math.floor(Math.random() * 4);
        switch (side) {
          case 0: return { x: Math.random() * VIRT_W, y: -margin };
          case 1: return { x: VIRT_W + margin, y: Math.random() * VIRT_H };
          case 2: return { x: Math.random() * VIRT_W, y: VIRT_H + margin };
          default: return { x: -margin, y: Math.random() * VIRT_H };
        }
      }

      function render() {
        g.clearRect(0, 0, VIRT_W, VIRT_H);
        drawBackground();
        const shakeX = (Math.random() - 0.5) * state.camera.shake;
        const shakeY = (Math.random() - 0.5) * state.camera.shake;
        g.save();
        g.translate(shakeX, shakeY);
        drawPlayer();
        drawOrbs();
        drawBallots();
        drawEnemies();
        drawProjectiles();
        drawEffects();
        g.restore();
        ctx.drawImage(off, 0, 0, off.width, off.height, 0, 0, screen.width, screen.height);
        drawCRT();
        drawGrain();
      }

      function drawBackground() {
        const patternSize = 32;
        g.fillStyle = '#0a0d18';
        g.fillRect(0, 0, VIRT_W, VIRT_H);
        for (let y = 0; y < VIRT_H; y += patternSize) {
          for (let x = 0; x < VIRT_W; x += patternSize) {
            g.fillStyle = `rgba(20, 24, 36, ${0.08 + Math.random() * 0.08})`;
            g.fillRect(x, y, patternSize, patternSize);
          }
        }
        const poster = 18;
        for (let y = 0; y < VIRT_H + poster; y += poster) {
          g.fillStyle = `rgba(60, 60, 70, ${Math.random() * 0.15})`;
          g.fillRect(0, y, VIRT_W, 1);
        }
      }

      function drawPlayer() {
        const player = state.player;
        const halo = SPRITES.halo;
        const frame = SPRITES.player[Math.floor((state.haloPulse % 1.2) / 0.6)];
        const pulse = (Math.sin(state.haloPulse * 2) + 1) * 0.2 + 0.5;
        g.save();
        g.translate(player.x, player.y);
        g.globalAlpha = 0.3 + pulse * 0.4;
        g.drawImage(halo, -8, -8, 16, 16);
        g.restore();
        g.save();
        g.translate(player.x, player.y);
        g.rotate(player.angle + Math.PI / 2);
        g.drawImage(frame, -8, -8, 16, 16);
        g.restore();
        const hpRatio = player.hp / player.max;
        g.fillStyle = '#1e2937';
        g.fillRect(player.x - 9, player.y + 10, 18, 3);
        g.fillStyle = '#2ee6a6';
        g.fillRect(player.x - 9, player.y + 10, 18 * hpRatio, 3);
      }

      function drawOrbs() {
        g.save();
        g.globalCompositeOperation = 'screen';
        g.fillStyle = 'rgba(255,214,102,0.8)';
        for (const orb of state.orbs) {
          g.beginPath();
          g.arc(orb.x, orb.y, 2, 0, Math.PI * 2);
          g.fill();
        }
        g.restore();
      }

      function drawBallots() {
        g.fillStyle = '#ffd166';
        for (const b of state.ballotsItems) {
          g.fillRect(b.x - 2, b.y - 2, 4, 4);
        }
      }

      function drawEnemies() {
        for (const enemy of state.enemies) {
          const spr = ENEMY_SPR[enemy.type];
          if (spr) g.drawImage(spr, enemy.x - 8, enemy.y - 8, 16, 16);
          g.fillStyle = 'rgba(10,10,10,0.4)';
          g.fillRect(enemy.x - 8, enemy.y + 10, 16, 2);
          g.fillStyle = '#ff4d6d';
          g.fillRect(enemy.x - 8, enemy.y + 10, 16 * (enemy.hp / enemy.max), 2);
        }
      }

      function drawProjectiles() {
        g.fillStyle = '#f8faff';
        for (const p of state.projectiles) {
          if (p.enemyShot) {
            g.fillStyle = '#ff4d6d';
            g.fillRect(p.x - 1, p.y - 1, 2, 2);
          } else {
            g.fillStyle = '#f8faff';
            g.fillRect(p.x - 1, p.y - 1, 2, 2);
          }
        }
      }

      function drawEffects() {
        for (const fx of state.effects) {
          const alpha = fx.life / fx.maxLife;
          g.fillStyle = fx.color || '#ffffff';
          g.globalAlpha = alpha;
          g.fillRect(fx.x - fx.size, fx.y - fx.size, fx.size * 2, fx.size * 2);
          g.globalAlpha = 1;
        }
      }

      function drawCRT() {
        const w = crt.width;
        const h = crt.height;
        const img = crtCtx.createImageData(w, h);
        for (let y = 0; y < h; y++) {
          const intensity = 0.05 * Math.sin(y * 0.6 + performance.now() * 0.01);
          for (let x = 0; x < w; x++) {
            const i = (y * w + x) * 4;
            const scan = (y % 2 === 0) ? 20 : 0;
            img.data[i] = scan;
            img.data[i + 1] = scan;
            img.data[i + 2] = scan;
            img.data[i + 3] = 80 + intensity * 255;
          }
        }
        crtCtx.putImageData(img, 0, 0);
      }

      function drawGrain() {
        const w = grain.width;
        const h = grain.height;
        const img = grainCtx.createImageData(w, h);
        for (let i = 0; i < img.data.length; i += 4) {
          const n = Math.random() * 24;
          img.data[i] = n;
          img.data[i + 1] = n;
          img.data[i + 2] = n;
          img.data[i + 3] = 20;
        }
        grainCtx.putImageData(img, 0, 0);
      }
    })();
  </script>
</body>
</html>
